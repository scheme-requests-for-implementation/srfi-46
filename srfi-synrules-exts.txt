-- Title --

Basic Syntax-rules Extensions

-- Author --

Taylor Campbell

-- Abstract --

This SRFI proposes two extensions to the R5RS[1] syntax-rules pattern
language: the first allows syntax-rules macros to generate macros,
where the macro-generated macros use ellipsis that is not used by the
macro-generating macros; the second allows for 'tail patterns.'

-- Rationale --

Macros that generate macros are fairly common and very useful in a
variety of circumstances, e.g. in CPS macros[2] for local continuation
macros.  R5RS[1] currently provides no mechanism for generating literal
ellipsis in a syntax-rules' clause's template -- all ellipsis in the
template is processed by the macro.  Macros that generate macros are
thereby restricted, since the generated macros are unable to make use
of ellipsis.  This is a severe restriction that can be removed by a
simple extension to the syntax-rules syntax.

It is often very convenient to be able to match the _last_ elements of
a list or vector in a pattern instead of just the _first_, but R5RS[1]
does not provide these 'tail patterns' in its specification of
syntax-rules.

-- Specification --

The syntax-rules syntax is extended so that there is an extra possible
token before the literal identifier list:

  (SYNTAX-RULES [<ellipsis-identifier>] (<literal-identifier> ...)
    (<pattern> <template>)
    ...)

ELLIPSIS-IDENTIFIER specifies the token used for ellipsis.  It defaults
to the usual R5RS[1] ellipsis identifier, ..., but it can be specified
to be any identifier, such as :::.  This identifier, when generated by
macros, is subject to the usual rules of hygiene.

The syntax-rules pattern language is also extended to allow 'tail
patterns.'  The following clauses are added to <pattern>:

 (<pattern> ... <ellipsis> <pattern> ...)
#(<pattern> ... <ellipsis> <pattern> ...)

The following clauses are added to the semantics of SYNTAX-RULES'
pattern matching:

  - P is of the form (P_1 ... P_x-1 P_x <ellipsis> P_x+1 ... P_y) where
    <ELLIPSIS> is the identifier ... and F is a proper list of M forms
    such that M >= Y, the first X-1 of which match P_1 through P_x-1,
    respectively, the forms F_x through F_m-(y-x), where F_i is the Ith
    element of the proper list F, all match P_x, and the forms
    F_m-(y-x) through F_m match the patterns P_x+1 through P_y.
  - P is of the form #(P_1 ... P_x-1 P_x <ellipsis> P_x+1 ... P_y)
    where <ELLIPSIS> is the identifier ... and F is a vector of M forms
    such that M >= Y, the first X-1 of which match P_1 through P_x-1,
    respectively, the forms F_x through F_m-(y-x), where F_i is the Ith
    element of the vector F, all match P_x and the forms F_m-(y-x)
    through F_m all match P_x+1 through P_y, respectively.

-- Examples --

;;; Examples of the user-specified ellipsis token extension

;;; Utility macro for CPS macros
(define-syntax apply-syntax-cont
  (syntax-rules ()
    ((_ (?k ?env ...) . ?args)
     (?k ?env ... . ?args))))

;;; Generates a list of temporaries, for example to implement LETREC
;;; (see below), and 'returns' it by CPS.
(define-syntax generate-temporaries
  (syntax-rules ()
    ((_ ?origs ?k)
     (letrec-syntax
         ((aux (syntax-rules ::: ()
                 ;; We use a trick here: pass the continuation _again_
                 ;; to AUX in case it contains ellipsis.  If we stuck
                 ;; it right into AUX's template, AUX would process the
                 ;; ellipsis in ?K as ellipsis for something in the AUX
                 ;; macro.
                 ((_ ?temps () ?k*)
                  (apply-syntax-cont ?k* ?temps))
                 ;; Be careful about the ellipsis!
                 ((_ (?temp :::) (?x ?more :::) ?k*)
                  (aux (?temp ::: new-temp)
                       (?more :::)
                       ?k*)))))
       (aux () ?origs ?k)))))

;;; Instead of having lots of auxiliary clauses in LETREC, like in the
;;; R5RS sample implementation, we use GENERATE-TEMPORARIES.  Instead
;;; of 'returning,' like an ordinary function, we create a continuation
;;;  for GENERATE-TEMPORARIES with LET-SYNTAX.  Since this continuation
;;; uses ellipsis, we must use the ellipsis token extension.
(define-syntax letrec
  (syntax-rules ()
    ((_ ((?var ?init) ...) ?body1 ?body2 ...)
     (let-syntax
         ((k (syntax-rules ::: ()
               ;; Use the same trick as with the continuations in
               ;; GENERATE-TEMPORARIES.  Be careful about the ellipsis!
               ((_ ((?var* ?init*) :::)
                   (?body1* ?body2* :::)
                   ;; Here are the actual arguments to the continuation
                   ;; -- the previous bits of the pattern were just the
                   ;; 'environment' of the continuation --:
                   (?temp :::))
                (let ((?var* (if #f #f)) ; Get an 'unspecific' value.
                      :::)
                  (let ((?temp ?init*) :::)
                    (set! ?var* ?temp) :::
                    (let () ?body1* ?body2* :::)))))))
       (generate-temporaries (?var ...)
         ;; Pass K the environment.
         (k ((?var ?init) ...) (?body1 ?body2 ...)))))))

;;; The next example uses two other macros that we don't define here:
;;; SYNTAX-SYMBOL? and UNION.  (SYNTAX-SYMBOL? <x> <sk> <fk>) expands
;;; to SK if X is a symbol or FK otherwise.  (UNION <s1> <s2> <k>)
;;; applies K with APPLY-SYNTAX-CONT to the union of the syntax lists
;;; S1 and S2 with no duplicates.  Both SYNTAX-SYMBOL? and UNION are
;;; possible to implement here, but we sha'n't bother with them here,
;;; as we only wish to show an example of macros generating macro-
;;; generating macros.

;;; ALL-SYMBOLS digs out all the symbols in a syntax.
(define-syntax all-symbols
  (syntax-rules ()
    ((_ (?x . ?y) ?k)
     (let-syntax
         ((k (syntax-rules ::: ()
               ((_ ?y* ?k*  (?symbol :::))
                (let-syntax
                    ((k* (syntax-rules :.. ()
                           ;; Doubly nested ellipsis: we use another
                           ;; distinct ellipsis token.
                           ((_ ?k** (?symbol* :..))
                            (union (?symbol  :::)
                                   (?symbol* :..)
                                   ?k**)))))
                  (all-symbols ?y* (k* ?k*)))))))
       (all-symbols ?x (k ?y ?k))))

    ((_ #(?x ...) ?k)
     (all-symbols (?x ...) ?k))

    ((_ ?x ?k)
     (syntax-symbol? ?x
       (apply-syntax-cont ?k (?x))
       (apply-syntax-cont ?k ())))))

(all-symbols (foo 4 bar #(#t (baz (#f quux)) zot) (mumble #(frotz)))
             (quote)) ; => (frotz mumble zot quux baz bar foo)

;;; Examples of the tail pattern extension

;;; Implement a fake BEGIN (fake because it doesn't allow for internal
;;; DEFINE, let alone internal DEFINEs that use the lexical environment
;;; of where the BEGIN was placed; it also doesn't allow for
;;; subexpressions returning multiple values).
(define-syntax fake-begin
  (syntax-rules ()
    ((_ ?body ... ?last-body-form)
     (let* ((ignored ?body) ...) ?last-body-form))))

-- Non-implementation --

There is no 'official' reference implementation here provided, because
this SRFI defines an extension to existing macro expanders, which all
vary vastly in implementation.  Al* Petrofsky suggested that there
still be here provided some examples of macro expanders that have been
modified to support these extensions already; for example, Al*'s own
expander, alexpander: <http://srfi.schemers.org/srfi-46/alexpander.scm>

-- References --

[1]
  Richard Kelsey, William Clinger, and Jonathon Rees (editors).
  The Revised^5 Report on the Algorithmic Language Scheme
  Higher-Order and Symbolic Computation, Vol. 11, No. 1, September,
    1998, and ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998.
  http://www.schemers.org/Documents/Standards/R5RS/

[2]
  Erik Hilsdale and Daniel P. Friedman.
  Writing Macros in Continuation-Passing Style
  Scheme and Functional Programming 2000, September, 2000.
  http://www.ccs.neu.edu/home/matthias/Scheme2000/hilsdale.ps

