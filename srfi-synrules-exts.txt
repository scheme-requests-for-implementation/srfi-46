-- Title --

Basic SYNTAX-RULES Extensions

-- Author --

Taylor Campbell

-- Abstract --

This SRFI proposes two extensions to the R5RS[1] SYNTAX-RULES pattern
language: the first allows SYNTAX-RULES macros to generate macros,
where the macro-generated macros use ellipsis that is not used by the
macro-generating macros (this extension is also provided by Dybvig and
Hieb's macro system, SYNTAX-CASE[2], and provided by many Scheme
implementations); the second allows for 'tail patterns.'

-- Rationale --

Macros that generate macros are fairly common and very useful in a
variety of circumstances, e.g. in CPS macros[3] for local continuation
macros.  R5RS[1] currently provides no mechanism for generating literal
ellipsis in a SYNTAX-RULES' clause's template -- all ellipsis in the
template is processed by the macro --.  Macros that generate macros are
thus restricted since the generated macros are unable to use ellipsis.
This is a severe restriction that can be removed by providing a very
simple token for generating literal ellipsis in a macro's template.

It is often very convenient to be able to match the _last_ element of a
list or vector in a pattern instead of just the _first_, but R5RS[1]
SYNTAX-RULES currently does not allow these 'tail patterns.'

-- Specification --

The SYNTAX-RULES pattern language is extended to accept a new special
token -- (... ...) -- in the template sections of SYNTAX-RULES macros.
In that place, the macro will generate literal ellipsis.  This not only
allows macros to generate macros that use ellipsis, but also any
arbitrary number of nested ellipsis-using macros, by nesting the nested
ellipsis: ((... ...) (... ...)), and any arbitrary amounts of nesting
beyond that.

The SYNTAX-RULES pattern language is also extended to allow tail
patterns.  The following clauses are added to <PATTERN>:

 (<pattern> ... <ellipsis> <pattern>)
#(<pattern> ... <ellipsis> <pattern>)

The following clauses are added to the semantics of SYNTAX-RULES:

  - P is of the form (P_1 ... P_n-1 P_n <ellipsis> P_n+1) where
    <ELLIPSIS> is the identifier ... and F is a proper list of M forms
    such that M > N, the first N-1 of which match P_1 through P_n-1,
    respectively, the forms G_n through G_m-1, where G_x is an element
    of the proper list F, all match P_n and the form G_m matches the
    pattern P_n+1.
  - P is of the form (P_1 ... P_n-1 P_n <ellipsis> P_n+1) where
    <ELLIPSIS> is the identifier ... and F is a vector of M forms such
    that M > N, the first N-1 of which match P_1 through P_n-1,
    respectively, the forms G_n through G_m-1, where G_x is an element
    of the vector F, all match P_n and the form G_m matches the pattern
    pattern P_n+1.

-- Examples --

;;;; Examples of the (... ...) extension

;; Utility macro for CPS macros.
(define-syntax apply-syntax-cont
  (syntax-rules ()
    ((_ (?k ?env ...) . ?args)
     (?k ?env ... . ?args))))

;; Generate a list of temporaries, for example to implement LETREC (see
;; below), and 'return' it using CPS.
(define-syntax generate-temporaries
  (syntax-rules ()
    ((_ ?origs ?k)
     (letrec-syntax
         ((aux (syntax-rules ()
                 ;; We use a trick here: pass the continuation _again_
                 ;; to AUX in case it contains ellipsis.  If we stuck
                 ;; it right into AUX's template, AUX would process the
                 ;; ellipsis in ?K as ellipsis for something in the AUX
                 ;; macro.
                 ((_ ?temps () ?k*)
                  (apply-syntax-cont ?k* ?temps))
                 ;; Be careful about the ellipsis!
                 ((_ (?temp (... ...)) (?x ?more (... ...)) ?k*)
                  (aux (?temp (... ...) new-temp)
                       (?more (... ...))
                       ?k*)))))
       (aux () ?origs ?k)))))

;; Instead of having lots of auxiliary clauses in LETREC, like in the
;; R5RS sample implementation, we use GENERATE-TEMPORARIES.  Instead of
;; 'returning,' like an ordinary function, we create a continuation for
;; GENERATE-TEMPORARIES with LET-SYNTAX.  Because this continuation
;; uses ellipsis, we must use the (... ...) extension.
(define-syntax letrec
  (syntax-rules ()
    ((_ ((?var ?init) ...) ?body1 ?body2 ...)
     (let-syntax
         ((k (syntax-rules ()
               ;; Use the same trick as with the continuations in
               ;; GENERATE-TEMPORARIES.  Be careful about the ellipsis!
               ((_ ((?var* ?init*) (... ...))
                   (?body1* ?body2* (... ...))
                   ;; Here are the actual arguments to the continuation
                   ;; -- the previous bits of the pattern were just the
                   ;; 'environment' of the continuation --:
                   (?temp ...))
                (let ((?var* (if #f #f)) ;; Get an 'unspecific' value
                      (... ...))
                  (let ((?temp ?init*) (... ...))
                    (set! ?var* ?temp) (... ...) 
                    (let () ?body1* ?body2* (... ...))))))))
       (generate-temporaries (?var ...)
         ;; Pass K the environment.
         (k ((?var ?init) ...) (?body1 ?body2 ...)))))))

;; The next example uses two other macros that we don't define here:
;; SYNTAX-SYMBOL? and UNION.  (syntax-symbol? X SK FK) expands to SK if
;; X is a symbol or FK otherwise.  (union S1 S2 K) applies K with
;; APPLY-SYNTAX-CONT to the union of the syntax lists S1 and S2 with no
;; duplicates.  Both SYNTAX-SYMBOL? and UNION are possible to implement
;; here, but we sha'n't bother with them here as we only wish to show
;; an example of using nested nested ellipsis: ((... ...) (... ...)).

;; ALL-SYMBOLS digs out all the symbols in a syntax.
(define-syntax all-symbols
  (syntax-rules ()
    ((_ (?x . ?y) ?k)
     (let-syntax
         ((k (syntax-rules ()
               ((_ ?y* ?k*  (?symbol (... ...)))
                (let-syntax
                    ((k* (syntax-rules ()
                           ((_ ?k** (?symbol* ((... ...)
                                               (... ...))))
                            (union (?symbol   (... ...))
                                   (?symbol* ((... ...)
                                              (... ...)))
                                   ?k**)))))
                  (all-symbols ?y* (k* ?k*)))))))
       (all-symbols ?x (k ?y ?k))))

    ((_ #(?x ...) ?k)
     (all-symbols (?x ...) ?k))

    ((_ ?x ?k)
     (syntax-symbol? ?x
       (apply-syntax-cont ?k (?x))
       (apply-syntax-cont ?k ())))))

(all-symbols (foo 4 bar #(#t (baz (#f quux)) zot) (mumble #(frotz)))
             (quote)) ; => (frotz mumble zot quux baz bar foo)

;;;; Examples of the tail pattern extension

;; Implement a fake BEGIN (fake because it doesn't allow for internal
;; DEFINEs, let alone internal DEFINEs that use the lexical environment
;; of where the BEGIN was placed).
(define-syntax fake-begin
  (syntax-rules ()
    ((_ ?expr ... ?last-expr)
     (let* ((frob ?expr) ...) ?last-expr))))

-- Non-Implementation --

No implementation is provided because this is SRFI is merely a request
to add two basic features to the SYNTAX-RULES pattern language, and so
the implementation of it would be a modification of an implementation
of SYNTAX-RULES.

-- References --

[1]
  Richard Kelsey, William Clinger, and Jonathon Rees (editors).
  The Revised^5 Report on the Algorithmic Language Scheme
  Higher-Order and Symbolic Computation, Vol. 11, No. 1, September,
    1998, and ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998.
  http://www.schemers.org/Documents/Standards/R5RS/

[2]
  R. Kent Dybvig.
  Writing Hygienic Macros in Scheme with SYNTAX-CASE.
  Technical Report 356, Indiana University, Bloomington, Indiana, June
    1992.
  http://citeseer.nj.nec.om/dybvig92writing.html

[3]
  Erik Hilsdale and Daniel P. Friedman.
  Writing Macros in Continuation-Passing Style
  Scheme and Functional Programming 2000, September, 2000.
  http://www.ccs.neu.edu/home/matthias/Scheme2000/hilsdale.ps

-- Copyright --

Copyright (C) Taylor Campbell (2003).  All rights reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published, and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works.  However, this
document itself may not be modified in any way, such as by removing the
copyright notice or references to the Scheme Request For Implementation
process or editors, except as needed for the purpose of developing
SRFIs in which case the procedures for copyrights defined in the SRFI
process must be followed, or as required to translate it into languages
other than English.

The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.

This document and the information contained herein are provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.
